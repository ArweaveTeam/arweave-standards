# ANS-104: Bundled Data v2.0 - Binary Serialization

Status: Standard

## Abstract

This document describes the data format and directions for reading and writing bundled binary data. Bundled data is a way of writing multiple independent data transactions (referred to as DataItems in this document) into one top level transaction. A DataItem shares many of the same properties as normal data transaction, in that it has an owner, data, tags, target, signature, and id. It differs in that is has no ability to transfer tokens, and no reward, as the top level transaction pays the reward for all bundled data.

This is a reworking of [ANS-102](ANS-102.md)

## Motivation

Bundling multiple logical data transactions into one transaction provides a number of benefits:

- To allow delegation of payment for a DataItem to a 3rd party, while maintaining the identity and signature of person who created the DataItem, without them needing to have a wallet with funds.

- Allow multiple DataItems to be written as a group.

- To increase the throughput of logically independent data writes to the Arweave network

This differs from [ANS-102](ANS-102.md), as it'll use a more compact data format which will allow for greater scaling.

## Reference Implementation

There is a reference implementation for the creation, signing, and verification of DataItems and working with bundles in [TypeScript](https://github.com/ArweaveTeam/arweave-data)

## Specification

### 1. Transaction Format

#### 1.1 Transaction Tags

A bundle of DataItems MUST have the following two tags present

- `Bundle-Format` a string describing the bundling format. The format for this standard is `binary`
- `Bundle-Version` a version string. The version referred to in this standard is `2.0.0`

Version changes may occur due to a change in encoding algorithm in the future. The initially proposed algorithm will use Rust's `bincode` crate

#### 1.2 Transaction Body Format

This format for the transaction body is binary data in the following bytes format

`N = number of DataItems`

| Bytes                              | Purpose                                       |
|---                                 |---                                            |
|32                                  |Numbers of data items                          |
|`N` x 64                            |Pairs of offset and entry ID [offset (32 bytes), entry ID (32 bytes)]|
|Remaining bytes                     |Binary encoded data items in bundle            |

#### 1.3 DataItem Format

A DataItem is a binary encoded (see [1.4]) object that has similar properties to a transaction:

|Field     |Description                                     | Encoding        | Optional |
|---       |---                                             |---              | --- |
|owner     |The public key of the owner                     | Binary            | :x: |
|target    |An address that this DataItem is being sent to  | Binary            | :heavy_check_mark: |
|nonce     |A value to prevent replay attacks               | Binary            |:heavy_check_mark: |
|tags      |An array of tag objects                         | Binary      |:x: |
|data      |The data contents                               | Binary            |      :x: |            
|signature |A signature produced by owner                   | Binary            |  :x: |
|id        |The id the item                                 | Binary            |:x: |

A tag object is a binary object representing a list of tuples (`List<(String, String)>`) with the following two keys representing each value.

|Field     |Description               | Encoding        |
|---       |---                       |---              |
|name      |Name of the tag           | Binary          | 
|value     |Value of the tag          | Binary          | 

The fields in the DataItem and Tags objects can be handled in an identical way as their counterpart in a regular Arweave transaction.

The `nonce` field in DataItem is optional, and is an arbitrary value to allow bundling gateways to provide protection from replay attacks against them or their users.

### 1.4 Binary encoding

A DataItem will use Rust's [bincode](https://github.com/bincode-org/bincode) crate to encode the JSON representation into a memory efficient binary representation 

### 2. DataItem signature and id

The signature, and id for a DataItem is built in a manner similar to Arweave 2.0 transaction signing. It uses the Arweave 2.0 deep-hash algorithm. The 2.0 deep-hash algorithm operates on arbitrarily nested arrays of binary data, i.e a recursive type of `DeepHashChunk = Uint8Array | DeepHashChunk[]`.

There is reference implementations for the deep-hash algorithm in [TypeScript](https://github.com/ArweaveTeam/arweave-js/blob/b1c4b2e378a1eb7dc1fbfaeee41492eb908a60c6/src/common/lib/deepHash.ts) and [Erlang](https://github.com/ArweaveTeam/arweave/blob/b316173cd42a53a59036241f8e164b615db9b40d/apps/arweave/src/ar_deep_hash.erl)

To generate a valid signature for a DataItem, the contents of the DataItem and static version tags, are passed to the deep-hash algorithm to obtain a message. This message is signed by the owner of the DataItem to produce the signature. The id of the DataItem, is the SHA256 digest of this signature.

The exact structure and content passed into the deep-hash algorithm to obtain the message to sign is as follows:

```
[
  utf8Encoded("dataitem"),
  utf8Encoded("1"),
  owner,
  target,
  nonce,
  [
    ... [ tag.name, tag.value ],
    ... [ tag.name, tag.value ],
    ...
  ],
  data
]
```

### 3. Expanding a bundle of DataItems

To read and expand a bundle of DataItems, each DataItem in the `items` should be verified using the verification algorithm. Individual items that fail verification MUST be discarded.

The verification algorithm will depend on the implementation. `Rust` and `bincode` would allow for compile time safety and simply throw an error if it's not correct.

In rare cases, an identical DataItem may exist in more that one transaction. That is, the contents and id of the DataItem are identical but exist in multiple Arweave transactions. Since they are identical, any of the copies can be discarded.

### 4. Writing a bundle of DataItems

To write a bundle of DataItems, each DataItem should constructed and signed, and placed in a transaction with the transaction body format and transaction tags specified in Section 1. Transaction Format.
